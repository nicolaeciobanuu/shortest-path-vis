{"ast":null,"code":"export function bfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  let nextNodesStack = [startNode];\n\n  while (nextNodesStack.length) {\n    const currentNode = nextNodesStack.shift();\n    if (currentNode === finishNode) return visitedNodesInOrder;\n\n    if (!currentNode.isWall && (currentNode.isStart || !currentNode.isVisited)) {\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n      const {\n        col,\n        row\n      } = currentNode;\n      let nextNode;\n\n      if (row > 0) {\n        nextNode = grid[row - 1][col];\n\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n\n      if (row < grid.length - 1) {\n        nextNode = grid[row + 1][col];\n\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n\n      if (col > 0) {\n        nextNode = grid[row][col - 1];\n\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n\n      if (col < grid[0].length - 1) {\n        nextNode = grid[row][col + 1];\n\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/cnico/Desktop/proiect/client/src/algs/bfs.js"],"names":["bfs","grid","startNode","finishNode","visitedNodesInOrder","nextNodesStack","length","currentNode","shift","isWall","isStart","isVisited","push","col","row","nextNode","previousNode"],"mappings":"AAAA,OAAO,SAASA,GAAT,CAAaC,IAAb,EAAmBC,SAAnB,EAA8BC,UAA9B,EAA0C;AAC/C,QAAMC,mBAAmB,GAAG,EAA5B;AACA,MAAIC,cAAc,GAAG,CAACH,SAAD,CAArB;;AACA,SAAOG,cAAc,CAACC,MAAtB,EAA8B;AAC5B,UAAMC,WAAW,GAAGF,cAAc,CAACG,KAAf,EAApB;AACA,QAAID,WAAW,KAAKJ,UAApB,EAAgC,OAAOC,mBAAP;;AAEhC,QACE,CAACG,WAAW,CAACE,MAAb,KACCF,WAAW,CAACG,OAAZ,IAAuB,CAACH,WAAW,CAACI,SADrC,CADF,EAGE;AACAJ,MAAAA,WAAW,CAACI,SAAZ,GAAwB,IAAxB;AACAP,MAAAA,mBAAmB,CAACQ,IAApB,CAAyBL,WAAzB;AACA,YAAM;AAACM,QAAAA,GAAD;AAAMC,QAAAA;AAAN,UAAaP,WAAnB;AACA,UAAIQ,QAAJ;;AACA,UAAID,GAAG,GAAG,CAAV,EAAa;AACXC,QAAAA,QAAQ,GAAGd,IAAI,CAACa,GAAG,GAAG,CAAP,CAAJ,CAAcD,GAAd,CAAX;;AACA,YAAI,CAACE,QAAQ,CAACJ,SAAd,EAAyB;AACvBI,UAAAA,QAAQ,CAACC,YAAT,GAAwBT,WAAxB;AACAF,UAAAA,cAAc,CAACO,IAAf,CAAoBG,QAApB;AACD;AACF;;AACD,UAAID,GAAG,GAAGb,IAAI,CAACK,MAAL,GAAc,CAAxB,EAA2B;AACzBS,QAAAA,QAAQ,GAAGd,IAAI,CAACa,GAAG,GAAG,CAAP,CAAJ,CAAcD,GAAd,CAAX;;AACA,YAAI,CAACE,QAAQ,CAACJ,SAAd,EAAyB;AACvBI,UAAAA,QAAQ,CAACC,YAAT,GAAwBT,WAAxB;AACAF,UAAAA,cAAc,CAACO,IAAf,CAAoBG,QAApB;AACD;AACF;;AACD,UAAIF,GAAG,GAAG,CAAV,EAAa;AACXE,QAAAA,QAAQ,GAAGd,IAAI,CAACa,GAAD,CAAJ,CAAUD,GAAG,GAAG,CAAhB,CAAX;;AACA,YAAI,CAACE,QAAQ,CAACJ,SAAd,EAAyB;AACvBI,UAAAA,QAAQ,CAACC,YAAT,GAAwBT,WAAxB;AACAF,UAAAA,cAAc,CAACO,IAAf,CAAoBG,QAApB;AACD;AACF;;AACD,UAAIF,GAAG,GAAGZ,IAAI,CAAC,CAAD,CAAJ,CAAQK,MAAR,GAAiB,CAA3B,EAA8B;AAC5BS,QAAAA,QAAQ,GAAGd,IAAI,CAACa,GAAD,CAAJ,CAAUD,GAAG,GAAG,CAAhB,CAAX;;AACA,YAAI,CAACE,QAAQ,CAACJ,SAAd,EAAyB;AACvBI,UAAAA,QAAQ,CAACC,YAAT,GAAwBT,WAAxB;AACAF,UAAAA,cAAc,CAACO,IAAf,CAAoBG,QAApB;AACD;AACF;AACF;AACF;AACF","sourcesContent":["export function bfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  let nextNodesStack = [startNode];\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.shift();\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n      const {col, row} = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}